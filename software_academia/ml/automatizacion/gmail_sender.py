from __future__ import annotations
import base64
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from typing import Dict, Any, List, Optional

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build

from software_academia.ml.automatizacion.config import (
    DRY_RUN,
    GMAIL_SENDER,
    GOOGLE_CREDENTIALS_PATH,
    GOOGLE_TOKEN_PATH,
    GMAIL_SCOPES,
)


# =========================
#  OAuth helpers
# =========================

def _get_gmail_service():
    creds: Optional[Credentials] = None

    if GOOGLE_TOKEN_PATH.exists():
        creds = Credentials.from_authorized_user_file(str(GOOGLE_TOKEN_PATH), GMAIL_SCOPES)

    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                str(GOOGLE_CREDENTIALS_PATH), GMAIL_SCOPES
            )
            creds = flow.run_local_server(port=0)

        GOOGLE_TOKEN_PATH.parent.mkdir(parents=True, exist_ok=True)
        with open(GOOGLE_TOKEN_PATH, 'w', escoding="utf-8") as token:
            token.write(creds.to_json())

    service = build('gmail', 'v1', credentials=creds)
    return service


# =========================
#  MIME builder
# =========================

def _build_mime(from_addr: str, to_addr: str, subject: str, text_body: str, html_body: str):
    msg = MIMEMultipart('alternative')
    msg['From'] = from_addr
    msg['To'] = to_addr
    msg['Subject'] = subject

    part_text = MIMEText(text_body or "", "plain", "utf-8")
    part_html = MIMEText(html_body or "", "html", "utf-8")

    msg.attach(part_text)
    msg.attach(part_html)
    return msg

def _encode_message(mine_msg) -> str:
    raw_bytes = mine_msg.as_bytes()
    raw_b64 = base64.urlsafe_b64encode(raw_bytes)
    return raw_b64.decode("utf-8")
        
# =========================
#  Public API
# =========================
def send_email_message(to_email: str, email_msg: Dict[str, Any]) -> Optional[str]:
    """
    Sends a single email message using Gmail API.
    - to_email: destination address (customer email)
    - email_msg: dict generated by writer.generate_email_message(...)
                 fields used: subject, text_body, html_body

    Returns Gmail message id (str) if sent, or None on DRY_RUN.
    """
    subject = email_msg.get("subject", "").strip()
    text_body = email_msg.get("text_body", "").strip()
    html_body = email_msg.get("html_body", "").strip()

    if not subject:
        raise ValueError("Missing subject for email.")
    if not to_email or "@" not in to_email:
        raise ValueError("Invalid destination email address.")

    # DRY RUN path: print preview and return
    if DRY_RUN:
        print("[DRY_RUN][GMAIL_SEND]")
        print(f"From: {GMAIL_SENDER}")
        print(f"To:   {to_email}")
        print(f"Subj: {subject}")
        print("-" * 60)
        print("TEXT:")
        print(text_body)
        print("-" * 60)
        print("HTML:")
        print(html_body)
        print("=" * 60)
        return None

    # Real send path
    service = _get_gmail_service()
    mime_msg = _build_mime(GMAIL_SENDER, to_email, subject, text_body, html_body)
    raw_encoded = _encode_message(mime_msg)

    resp = service.users().messages().send(
        userId="me",
        body={"raw": raw_encoded}
    ).execute()

    # resp contains 'id', 'threadId', etc.
    return resp.get("id")




       